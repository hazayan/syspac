name: Build and Update Repository (Rust)

on:
  push:
    branches: ["**"]
    paths-ignore:
      - "**.md"
      - "LICENSE"
  repository_dispatch:
    types: [rebuild-all]

env:
  RELEASE_TAG: repo
  REPO_NAME: syspac

jobs:
  preflight:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository_owner }}/syspac:latest
    steps:
      - name: Checkout code with submodules
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Debug syspac image environment
        shell: bash
        run: |
          echo "User: $(whoami)"
          echo "PATH: $PATH"
          echo "Workspace: ${GITHUB_WORKSPACE}"
          echo "Listing /usr/local/bin:"
          ls -l /usr/local/bin || echo "/usr/local/bin not found"
          echo "Where is syspac?"
          command -v syspac || echo "syspac not in PATH"

      - name: Fix repository ownership for container user
        shell: bash
        run: |
          # syspac (via libgit2) requires the repo to be owned by the current user.
          # The container user should already own the workspace; if not, adjust directly.
          chown -R "$(id -u):$(id -g)" "${GITHUB_WORKSPACE}" || true

      - name: Detect changed packages
        id: changes
        shell: bash
        run: |
          # Check if this is a rebuild-all command
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]] && [[ "${{ github.event.action }}" == "rebuild-all" ]]; then
            echo "üî® Rebuild all packages requested"
            CHANGED=$(syspac detect-changes --all --paths)
          else
            echo "üîç Detecting changed packages"
            CHANGED=$(syspac detect-changes --paths)
          fi

          echo "Changed packages to build: $CHANGED"
          echo "packages=${CHANGED}" >> $GITHUB_OUTPUT

          # Also get JSON output for debugging
          echo "JSON output:"
          syspac detect-changes --paths --format json

      - name: List all packages (debug)
        shell: bash
        run: |
          echo "All packages in repository:"
          syspac list-packages --verbose

      - name: List current packages (source of truth)
        id: current_pkgs
        shell: bash
        run: |
          # Get packages as newline-separated list and join into a single space-separated string
          mapfile -t pkgs < <(syspac list-packages)
          CURRENT="${pkgs[*]}"
          echo "Current packages: ${CURRENT}"
          echo "current=${CURRENT}" >> "$GITHUB_OUTPUT"

    outputs:
      packages: ${{ steps.changes.outputs.packages }}
      current_packages: ${{ steps.current_pkgs.outputs.current }}

  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    needs:
      - preflight
    if: needs.preflight.outputs.packages != ''

    steps:
      - name: Checkout code with submodules
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Create repository directory
        run: |
          mkdir -p repo/x86_64

      - name: Download existing release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üì¶ Downloading existing packages from release..."

          # Check if release exists
          if gh release view ${{ env.RELEASE_TAG }} >/dev/null 2>&1; then
            echo "Release exists, downloading existing assets..."

            # Download all existing assets to preserve them
            cd repo/x86_64
            gh release download ${{ env.RELEASE_TAG }} --pattern "*.pkg.tar.zst*" || echo "No packages to download"
            gh release download ${{ env.RELEASE_TAG }} --pattern "syspac.db*" || echo "No database to download"
            gh release download ${{ env.RELEASE_TAG }} --pattern "syspac.files*" || echo "No files database to download"
            cd ../..

            echo "Downloaded existing assets:"
            ls -lh repo/x86_64/ || echo "Directory is empty"
          else
            echo "No existing release found, starting fresh"
          fi

      - name: Use current packages from preflight
        id: current_pkgs
        run: |
          CURRENT="${{ needs.preflight.outputs.current_packages }}"
          echo "Current packages (from preflight): ${CURRENT}"
          echo "current=${CURRENT}" >> $GITHUB_OUTPUT

      - name: Prune packages that no longer exist
        working-directory: repo/x86_64
        run: |
          set -e

          CURRENT="${{ steps.current_pkgs.outputs.current }}"

          echo "Current package set from syspac:"
          echo "${CURRENT}"

          # If there are no package files yet, nothing to prune
          shopt -s nullglob
          PKGFILES=( ./*.pkg.tar.* )
          if [ ${#PKGFILES[@]} -eq 0 ]; then
            echo "No existing package files to prune"
            exit 0
          fi

          # Convert CURRENT into a newline-separated list for easier matching
          # shellcheck disable=SC2086
          printf '%s\n' ${CURRENT} > /tmp/current-packages.txt

          prune_file() {
            local f="$1"
            local base="${f##*/}"        # strip path
            base="${base%%.pkg.tar.*}"   # strip extension
            # Strip arch (last -separated field), assuming name-ver-rel-arch.pkg.tar.*
            base="${base%-*-*-*}"
            echo "$base"
          }

          for f in ./*.pkg.tar.*; do
            [ -e "$f" ] || continue

            PKGNAME=$(prune_file "$f")

            if ! grep -qx "$PKGNAME" /tmp/current-packages.txt; then
              echo "Removing obsolete package file: $f (pkgname=$PKGNAME not in current packages)"
              rm -f "$f"
            else
              echo "Keeping package file: $f (pkgname=$PKGNAME is current)"
            fi
          done

      - name: Import GPG key
        run: |
          gpg --import --no-tty <<<"${{ secrets.GPG_KEY }}"
          gpg --import-ownertrust --no-tty <<<"${{ vars.GPG_KEY_ID }}:5:"

      - name: Import GPG key
        run: |
          gpg --import --no-tty <<<"${{ secrets.GPG_KEY }}"
          gpg --import-ownertrust --no-tty <<<"${{ vars.GPG_KEY_ID }}:5:"

      - name: Build builder image
        run: |
          docker build -t package-builder build-container/

      - name: Build packages
        run: |
          docker run --rm \
            --privileged \
            -e GITHUB_REPOSITORY="${{ github.repository }}" \
            -e RELEASE_TAG="${{ env.RELEASE_TAG }}" \
            -e CHANGED_PACKAGES="${{ needs.preflight.outputs.packages }}" \
            -e GPG_KEY_DATA="${{ secrets.GPG_KEY }}" \
            -e GPG_KEY_ID="${{ vars.GPG_KEY_ID }}" \
            -v ${{ github.workspace }}:/build \
            -v ${{ github.workspace }}/repo:/repo \
            package-builder

      - name: Rebuild and sign pacman database from current packages (in container)
        working-directory: repo/x86_64
        env:
          GPG_KEY_ID: ${{ vars.GPG_KEY_ID }}
          RELEASE_TAG: ${{ env.RELEASE_TAG }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -e

          # At this point, repo/x86_64 contains:
          # - Any previously downloaded packages/DB from the release
          # - Newly built packages from the container
          # and has been pruned to the current package set.

          shopt -s nullglob
          PKGFILES=( ./*.pkg.tar.* )
          if [ ${#PKGFILES[@]} -eq 0 ]; then
            echo "No package files found; skipping container repo-add."
            exit 0
          fi

          echo "Rebuilding and signing pacman DB inside Arch container from the following packages:"
          ls -1 ./*.pkg.tar.*

          # Run a one-shot Arch-based container that has repo-add and GPG available.
          # We mount only repo/x86_64 and pass the key material into the container.
          docker run --rm \
            -e GPG_KEY_ID="${GPG_KEY_ID}" \
            -e GPG_KEY_DATA="${{ secrets.GPG_KEY }}" \
            -v "$PWD":/repo/x86_64 \
            archlinux:base \
            bash -lc '
              set -e
              pacman -Sy --noconfirm pacman-contrib gnupg

              mkdir -p /root/.gnupg
              chmod 700 /root/.gnupg

              if [ -n "${GPG_KEY_DATA-}" ]; then
                echo "Importing GPG key inside container..."
                gpg --import --no-tty <<<"${GPG_KEY_DATA}"
                gpg --import-ownertrust --no-tty <<<"${GPG_KEY_ID}:5:"
              fi

              cd /repo/x86_64

              # Remove existing DB files
              rm -f syspac.db* syspac.files* syspac.db.tar.gz.lck || true

              shopt -s nullglob
              # Collect all package archives (exclude signatures)
              PKGFILES=( ./*.pkg.tar.* )
              PKGONLY=()
              for f in "${PKGFILES[@]}"; do
                # Skip signature files
                if [[ "$f" == *.sig ]]; then
                  continue
                fi
                PKGONLY+=( "$f" )
              done

              if [ ${#PKGONLY[@]} -eq 0 ]; then
                echo "No package files found; skipping repo-add in container."
                exit 0
              fi

              echo "Signing packages in container..."
              if [ -n "${GPG_KEY_ID-}" ]; then
                for pkg in "${PKGONLY[@]}"; do
                  if [ -f "${pkg}" ]; then
                    echo "Signing ${pkg}..."
                    gpg --detach-sign --batch --yes -u "${GPG_KEY_ID}" "${pkg}" || {
                      echo "Warning: failed to sign ${pkg}, continuing."
                    }
                  fi
                done
              else
                echo "GPG_KEY_ID is not set in container; skipping package signing."
              fi

              echo "Creating database (signed if key is available) in container..."
              if [ -n "${GPG_KEY_ID-}" ]; then
                repo-add -s -k "${GPG_KEY_ID}" -n -R syspac.db.tar.gz "${PKGONLY[@]}" || {
                  echo "repo-add with signing failed; attempting unsigned..."
                  repo-add -n -R syspac.db.tar.gz "${PKGONLY[@]}"
                }
              else
                repo-add -n -R syspac.db.tar.gz "${PKGONLY[@]}"
              fi
            '

      - name: Create release notes
        run: |
          cat > release-notes.md <<'EOF'
          Last updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          Built packages in this update: ${{ needs.preflight.outputs.packages }}

          ## Usage

          Add this repository to your `/etc/pacman.conf`:

          ```ini
          [syspac]
          SigLevel = Optional TrustAll
          Server = https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_TAG }}
          ```

          Then run:
          ```bash
          sudo pacman -Sy
          sudo pacman -S <package-name>
          ```
          EOF

      - name: Update Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          echo "üì§ Updating release with all packages (old + new, pruned to current set)..."

          # Ensure the directory has at least one file (for diagnostics / debug)
          if [ ! "$(ls -A repo/x86_64)" ]; then
            echo "‚ö†Ô∏è  No packages found, creating placeholder"
            echo "This directory is reserved for x86_64 packages" > "repo/x86_64/README.txt"
          fi

          # List what we're about to upload
          echo "Files to upload:"
          ls -lh repo/x86_64/

          # Determine what artifacts actually exist
          shopt -s nullglob

          PKGFILES=( repo/x86_64/*.pkg.tar.* )
          DBFILES=( repo/x86_64/syspac.db* repo/x86_64/syspac.files* )

          HAS_PKGS=false
          HAS_DB=false

          if [ ${#PKGFILES[@]} -gt 0 ]; then
            HAS_PKGS=true
          fi

          if [ ${#DBFILES[@]} -gt 0 ]; then
            HAS_DB=true
          fi

          if [ "$HAS_PKGS" = false ] && [ "$HAS_DB" = false ]; then
            echo "‚ö†Ô∏è  No packages or database files found; skipping release update."
            exit 0
          fi

          # Delete existing release and tag if they exist
          echo "Deleting old release (if any)..."
          gh release delete ${{ env.RELEASE_TAG }} --yes || echo "No existing release to delete"
          git tag -d ${{ env.RELEASE_TAG }} || echo "No existing tag to delete"
          git push origin :refs/tags/${{ env.RELEASE_TAG }} || echo "No remote tag to delete"

          # Build argument list for gh release create based on existing files
          ARGS=( "${{ env.RELEASE_TAG }}" --title "Package Repository" --notes-file release-notes.md )

          if [ "$HAS_PKGS" = true ]; then
            ARGS+=( repo/x86_64/*.pkg.tar.* )
          fi

          if [ "$HAS_DB" = true ]; then
            # Only include DB/files patterns that actually match
            for f in repo/x86_64/syspac.db* repo/x86_64/syspac.files*; do
              if [ -e "$f" ]; then
                ARGS+=( "$f" )
              fi
            done
          fi

          echo "Creating new release with current packages and DB (if any)..."
          gh release create "${ARGS[@]}"

          # Force update tag
          git tag -f ${{ env.RELEASE_TAG }}
          git push -f origin ${{ env.RELEASE_TAG }}

          echo "‚úÖ Release updated successfully"
