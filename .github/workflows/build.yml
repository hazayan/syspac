name: Build and Update Repository (Rust)

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "LICENSE"
  repository_dispatch:
    types: [rebuild-all]

env:
  RELEASE_TAG: repository
  REPO_NAME: syspac

jobs:
  preflight:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code with submodules
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Setup Syspac Tool
        uses: ./
        with:
          version: latest
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect changed packages
        id: changes
        run: |
          # Check if this is a rebuild-all command
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]] && [[ "${{ github.event.action }}" == "rebuild-all" ]]; then
            echo "üî® Rebuild all packages requested"
            CHANGED=$(syspac detect-changes --all --paths)
          else
            echo "üîç Detecting changed packages"
            CHANGED=$(syspac detect-changes --paths)
          fi

          echo "Changed packages to build: $CHANGED"
          echo "packages=${CHANGED}" >> $GITHUB_OUTPUT

          # Also get JSON output for debugging
          echo "JSON output:"
          syspac detect-changes --paths --format json

      - name: List all packages (debug)
        run: |
          echo "All packages in repository:"
          syspac list-packages --verbose

    outputs:
      packages: ${{ steps.changes.outputs.packages }}

  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    needs:
      - preflight
    if: needs.preflight.outputs.packages != ''

    steps:
      - name: Checkout code with submodules
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Create repository directory
        run: |
          mkdir -p repo/x86_64

      - name: Download existing release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üì¶ Downloading existing packages from release..."

          # Check if release exists
          if gh release view ${{ env.RELEASE_TAG }} >/dev/null 2>&1; then
            echo "Release exists, downloading existing assets..."

            # Download all existing assets to preserve them
            cd repo/x86_64
            gh release download ${{ env.RELEASE_TAG }} --pattern "*.pkg.tar.zst*" || echo "No packages to download"
            gh release download ${{ env.RELEASE_TAG }} --pattern "syspac.db*" || echo "No database to download"
            gh release download ${{ env.RELEASE_TAG }} --pattern "syspac.files*" || echo "No files database to download"
            cd ../..

            echo "Downloaded existing assets:"
            ls -lh repo/x86_64/ || echo "Directory is empty"
          else
            echo "No existing release found, starting fresh"
          fi

      - name: Build builder image
        run: |
          docker build -t package-builder build-container/

      - name: Import GPG key
        run: |
          gpg --import --no-tty <<<"${{ secrets.GPG_KEY }}"
          gpg --import-ownertrust --no-tty <<<"${{ vars.GPG_KEY_ID }}:5:"

      - name: Build packages
        run: |
          docker run --rm \
            --privileged \
            -e GITHUB_REPOSITORY="${{ github.repository }}" \
            -e CHANGED_PACKAGES="${{ needs.preflight.outputs.packages }}" \
            -e GPG_KEY_DATA="${{ secrets.GPG_KEY }}" \
            -e GPG_KEY_ID="${{ vars.GPG_KEY_ID }}" \
            -v ${{ github.workspace }}:/build \
            -v ${{ github.workspace }}/repo:/repo \
            package-builder

      - name: Create release notes
        run: |
          cat > release-notes.md <<'EOF'
          Last updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          Built packages in this update: ${{ needs.preflight.outputs.packages }}

          ## Usage

          Add this repository to your `/etc/pacman.conf`:

          ```ini
          [syspac]
          SigLevel = Optional TrustAll
          Server = https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_TAG }}
          ```

          Then run:
          ```bash
          sudo pacman -Sy
          sudo pacman -S <package-name>
          ```
          EOF

      - name: Update Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üì§ Updating release with all packages (old + new)..."

          # Ensure the directory has at least one file
          if [ ! "$(ls -A repo/x86_64)" ]; then
            echo "‚ö†Ô∏è  No packages found, creating placeholder"
            echo "This directory is reserved for x86_64 packages" > "repo/x86_64/README.txt"
          fi

          # List what we're about to upload
          echo "Files to upload:"
          ls -lh repo/x86_64/

          # Delete existing release and tag
          echo "Deleting old release..."
          gh release delete ${{ env.RELEASE_TAG }} --yes || true
          git tag -d ${{ env.RELEASE_TAG }} || true
          git push origin :refs/tags/${{ env.RELEASE_TAG }} || true

          # Create new release with ALL packages (old + new)
          echo "Creating new release with all packages..."

          # Only upload actual package files, not empty database files
          if ls repo/x86_64/*.pkg.tar.zst 1> /dev/null 2>&1; then
            gh release create ${{ env.RELEASE_TAG }} \
              --title "Package Repository" \
              --notes-file release-notes.md \
              repo/x86_64/*.pkg.tar.zst* repo/x86_64/syspac.{db,files}{,.tar.gz}
          else
            echo "‚ö†Ô∏è  No packages built, creating release with database only"
            gh release create ${{ env.RELEASE_TAG }} \
              --title "Package Repository" \
              --notes-file release-notes.md \
              repo/x86_64/syspac.{db,files}{,.tar.gz}
          fi

          # Force update tag
          git tag -f ${{ env.RELEASE_TAG }}
          git push -f origin ${{ env.RELEASE_TAG }}

          echo "‚úÖ Release updated successfully"
