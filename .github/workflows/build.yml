name: Build and Update Repository

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "LICENSE"

env:
  RELEASE_TAG: repository
  REPO_NAME: syspac

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code with submodules
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Create repository directory
        run: |
          mkdir -p repo/x86_64

      - name: Build builder image
        run: |
          docker build -t package-builder build-container/

      - name: Detect changed packages
        id: changes
        run: |
          # Function to get base ref for comparison
          get_base_ref() {
            # For push events, use the parent of the current commit
            git rev-parse HEAD^
          }

          # Function to get package version from PKGBUILD
          get_pkg_version() {
            local pkgbuild="$1"
            if [ -f "$pkgbuild" ]; then
              # Source PKGBUILD in a subshell to get version safely
              (source "$pkgbuild" 2>/dev/null && echo "${pkgver}-${pkgrel}") || echo "unknown"
            else
              echo "unknown"
            fi
          }

          # Get base ref for comparison
          BASE_REF=$(get_base_ref) || BASE_REF=""

          # Get list of all package directories
          mapfile -t ALL_PKGS < <(
            # List submodules with PKGBUILD
            git submodule foreach --quiet 'if [ -f "PKGBUILD" ]; then echo "$name"; fi'
            # List direct directories with PKGBUILD
            find . -maxdepth 2 -name PKGBUILD -exec dirname {} \; | while read -r dir; do
              dir=${dir#./}
              if [ -d "$dir" ] && [ ! -d "$dir/.git" ]; then
                echo "$dir"
              fi
            done | sort -u
          )

          # Initialize arrays for changed and unchanged packages
          CHANGED_PKGS=()
          UNCHANGED_PKGS=()

          echo "Checking for package changes..."
          for pkg in "${ALL_PKGS[@]}"; do
            if [ -z "$BASE_REF" ]; then
              # If no base ref (first push), consider package as changed
              echo "First push or base not available - will build $pkg"
              CHANGED_PKGS+=("$pkg")
              continue
            fi

            # Check if package files changed
            if git diff --quiet "$BASE_REF" -- "$pkg"; then
              if [ -f "$pkg/PKGBUILD" ]; then
                echo "$pkg: No changes detected, skipping"
                UNCHANGED_PKGS+=("$pkg")
              fi
            else
              echo "$pkg: Changes detected, will rebuild"
              CHANGED_PKGS+=("$pkg")
            fi
          done

          # Convert array to space-separated string
          FINAL_CHANGES=$(IFS=' '; echo "${CHANGED_PKGS[*]}")

          # Output results
          echo "Changed packages to build: $FINAL_CHANGES"
          echo "packages=${FINAL_CHANGES}" >> $GITHUB_OUTPUT

          # Debug information
          echo "Debug information:"
          echo "Base ref: $BASE_REF"
          echo "Total packages found: ${#ALL_PKGS[@]}"
          echo "Packages to build: ${#CHANGED_PKGS[@]}"
          echo "Packages skipped: ${#UNCHANGED_PKGS[@]}"

      - name: Import GPG key
        if: steps.changes.outputs.packages != ''
        run: |
          gpg --import --no-tty <<<"${{ secrets.GPG_KEY }}"
          gpg --import-ownertrust --no-tty <<<"${{ vars.GPG_KEY_ID }}:5:"

      - name: Build packages
        if: steps.changes.outputs.packages != ''
        run: |
          docker run --rm \
            --privileged \
            -e GITHUB_REPOSITORY="${{ github.repository }}" \
            -e CHANGED_PACKAGES="${{ steps.changes.outputs.packages }}" \
            -e GPG_KEY_DATA="${{ secrets.GPG_KEY }}" \
            -e GPG_KEY_ID="${{ vars.GPG_KEY_ID }}" \
            -v ${{ github.workspace }}:/build \
            -v ${{ github.workspace }}/repo:/repo \
            package-builder

      - name: Update Release
        if: steps.changes.outputs.packages != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Ensure the directory has at least one file
          if [ ! "$(ls -A repo/x86_64)" ]; then
            echo "This directory is reserved for x86_64 packages" > "repo/x86_64/README.txt"
          fi

          # Delete existing release and tag
          gh release delete ${{ env.RELEASE_TAG }} --yes || true
          git tag -d ${{ env.RELEASE_TAG }} || true
          git push origin :refs/tags/${{ env.RELEASE_TAG }} || true

          # Create new release
          gh release create ${{ env.RELEASE_TAG }} \
            --title "Package Repository" \
            --notes "Last updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
            repo/x86_64/*

          # Force update tag
          git tag -f ${{ env.RELEASE_TAG }}
          git push -f origin ${{ env.RELEASE_TAG }}

      - name: Upload Build Logs
        if: always() && steps.changes.outputs.packages != ''
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: |
            repo/build-output.txt
            repo/*-build.log
          retention-days: 7
          if-no-files-found: warn
